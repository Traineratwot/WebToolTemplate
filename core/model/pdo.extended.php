<?php

	namespace PDOExtended;

	use PDO;
	use PDOStatement;

	/** Расширение для класса PDO
	 *
	 * @version       2.0
	 * @author        Insys <intsystem88@gmail.com>
	 * @copyright (c) 2013, Insys
	 * @link          https://github.com/InSys/pdo-extended
	 * @license       http://opensource.org/licenses/GPL-2.0 The GNU General Public License (GPL-2.0)
	 */
	class PDOExtended extends PDO
	{
		private $query_count = 0;
		public  $dsn;
		const DSN_REGEX = '/^(?P<user>\w+)(:(?P<password>\w+))?@(?P<host>[.\w]+)(:(?P<port>\d+))?\\\\(?P<database>\w+)$/im';

		public function __construct($dsn, $username = NULL, $password = NULL, $driverOptions = [])
		{
			parent::__construct($dsn, $username, $password, $driverOptions);
			$this->ParseDsn($dsn);
			$this->setAttribute(PDO::ATTR_STATEMENT_CLASS, ['PDOExtended\PDOExtendedStatement', [$this]]);
		}

		public function ParseDsn($dsn)
		{
			$result = [
				'driver'   => '',
				'user'     => '',
				'password' => '',
				'host'     => 'localhost',
				'port'     => 3306,
				'database' => '',
			];
			if (strlen($dsn) == 0) {
				return FALSE;
			}
			$a = explode(':', $dsn);
			if ($a > 1) {
				$result['driver'] = $a[0];
			} else {
				return FALSE;
			}

			if (preg_match(self::DSN_REGEX, $dsn, $matches)) {
				if (count($matches) > 0) {
					foreach ($result as $key => $value) {
						if (array_key_exists($key, $matches) and !empty($matches[$key])) {
							$result[$key] = $matches[$key];
						}
					}
				}
			}
			$this->dsn = $result;
			return $result;
		}

		public function query_count_increment()
		{
			$this->query_count++;
		}

		public function __get($name)
		{
			if ($name == 'query_count') {
				return $this->query_count;
			}
			return NULL;
		}

		public function __set($name, $value)
		{
			return FALSE;
		}

		public function __isset($name)
		{
			if ($name == 'query_count') {
				return TRUE;
			}
			return FALSE;
		}

		/**
		 * @param string $statement SQL request
		 * @return bool|PDOStatement
		 */
		public function query($statement, ...$a)
		{
			$this->query_count_increment();
			return parent::query($statement); // TODO: Change the autogenerated stub
		}

		/**
		 * @param string $statement SQL request
		 * @return bool|PDOStatement
		 */
		public function exec($statement)
		{
			$this->query_count_increment();
			return parent::exec($statement); // TODO: Change the autogenerated stub
		}

		public static function __set_state($arr)
		{
			global $core;
			return $core->db;
		}

		/**
		 * @param       $statement
		 * @param array $driver_options
		 * @return bool|PDOExtendedPoolStatement
		 */
		public function poolPrepare($statement, array $driver_options = [])
		{
			$this->setAttribute(PDO::ATTR_STATEMENT_CLASS, ['PDOExtended\PDOExtendedPoolStatement', [$this]]);
			$r = parent::prepare($statement, $driver_options);
			$this->setAttribute(PDO::ATTR_STATEMENT_CLASS, ['PDOExtended\PDOExtendedStatement', [$this]]);
			return $r;
		}

	}

	class PDOExtendedStatement extends PDOStatement
	{
		private $connection;

		protected function __construct(PDO $connection)
		{
			$this->connection = $connection;
		}

		public function execute($input_parameters = NULL)
		{
			$this->connection->query_count_increment();
			return parent::execute($input_parameters); // TODO: Change the autogenerated stub
		}
	}

	class PDOExtendedPoolStatement extends PDOStatement
	{
		protected $connection;
		public    $pool;

		protected function __construct(PDO $connection)
		{
			$this->connection = $connection;
		}

		/**
		 * Add prepared query to pool queue
		 * @param $input_parameters
		 * @return $this|bool
		 */
		public function execute($input_parameters = NULL)
		{
			$this->connection->query_count_increment();
			$this->queryString;
			$this->pool[] = $this->interpolateQuery($this->queryString, $input_parameters);
			return $this;
		}

		/**
		 * execute queries pool
		 *
		 * sqlite cannot execute more than one query at a time
		 * @param int $limit //count of query from chunk; default 10
		 * @return Array<PDOExtendedStatement>
		 */
		public function run($limit = 10)
		{
			//sqlite cannot execute more than one query at a time
			if ($this->connection->dsn['driver'] == "sqlite") {
				$limit = 1;
			}
			$pools   = array_chunk($this->pool, $limit);
			$queries = [];
			foreach ($pools as $pool) {
				$query     = implode(";", $pool) . ';';
				$queries[] = $this->connection->query($query);
			}
			return $queries;
		}

		public function interpolateQuery($query, $params) {
			$keys = array();
			$values = $params;
			$values_limit = [];

			$words_repeated = array_count_values(str_word_count($query, 1, ':_'));

			# build a regular expression for each parameter
			foreach ($params as $key => $value) {
				if (is_string($key)) {
					$keys[] = '/:'.$key.'/';
					$values_limit[$key] = (isset($words_repeated[':'.$key]) ? intval($words_repeated[':'.$key]) : 1);
				} else {
					$keys[] = '/[?]/';
					$values_limit = [];
				}
				if (is_string($value))
					$values[$key] = $value;

				if (is_array($value))
					$values[$key] = json_encode($value);

				if (is_null($value))
					$values[$key] = 'NULL';
			}
			array_walk($values, create_function('&$v, $k', 'if (!is_numeric($v) && $v!="NULL") $v = "\'".$v."\'";'));
			if (is_array($values)) {
				foreach ($values as $key => $val) {
					if (isset($values_limit[$key])) {
						$query = preg_replace(['/:'.$key.'/'], [$val], $query, $values_limit[$key], $count);
					} else {
						$query = preg_replace(['/:'.$key.'/'], [$val], $query, 1, $count);
					}
				}
				unset($key, $val);
			} else {
				$query = preg_replace($keys, $values, $query, 1, $count);
			}

			unset($keys, $values, $values_limit, $words_repeated);

			return trim(trim($query), ';');
		}
	}